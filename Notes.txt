Every Embedded Linux Project requires following four components : 

Toolchain : To Compile all the other elements.
Bootloader : To Initialise the board and load kernel(Application,System Programs,Operating System,Device Tree)
Kernel : To manage system resources.
Root filesystem : To Run applications, Container for linux kernel configuration files, system programs, application.
Device Tree : A tree data structure with nodes informing linux kernel about the connected HW devices enabling proper
              initialzing of the relevant device drivers.  

A build system such as Yocto or Build root generates the above neccessary components for us.



---------------------------------------ARM Embedded Linux Online Course-----------------------------

----------------Lec 1 : Introduction------------------

Operating system provides following services : 
                     System call interface, 
                     Process Management, 
                     Memory Management,
                     Virtual File System,
                     Device Drivers for I/O Management.

Linux Kernel also provides above same services.

We will prefer LTS i.e. Long terms kernels having long term maintainence.


---------------------Lec 2 : Linux Based Embedded Systems--------------------------

The difference between MCU and SoC is that in MCU RAM,ROM(Bootflash),CPU, I/O are all on the same chip .
                                            In SoC RAM Memory and additional component Mass Memory are not present on the same chip
                                            while CPI, I/O, Bootflash are present on the same chip.

The kernel modules are loaded into kernel using commands such as insmod or modprobe or maybe autoloaded through modifying a file of Embedded Linux distro.

In Linux based embedded system following components are mandatory : 

Bootloader : To Initialise the board and load kernel(Application,System Programs,Operating System,Device Tree).
             Bootloader is a software executed at startup , it copies the Application,System Programs,Operating System,
             Device Tree from Mass Memory Flash to RAM and also initializes RAM Memory controller. 

Device Tree : A tree data structure with nodes informing linux kernel about the connected HW devices enabling proper
              initialzing of the relevant device drivers. This information is provided to the kernel through 
              device tree blob file produced from Device tree source file.

 Kernel     : To manage system resources and provide services : Process Management, Memory Management, Scheduling,
              Inter process communication, I/O Management, File Syste, Networking.
              Kernel code is Architecture-independent operating system code.


System Programs : Provide Status Information, File Modification, Programming Language support, program loading and execution,
                  Communications, application programs.

Application :  Software required to provide end user service .

Root filesystem : To Run applications, Container for linux kernel configuration files, system programs, application.
                  Contains first user-level process init.

		/	        # Disk root
	/bin			# Repository for binary files
	/lib			# Repository for library files
	/dev			# Repository for device files
		console c 5 1	# Console device file
		null c 1 3	# Null device file
		zero c 1 5 	# All-zero device file
		tty c 5 0 	# Serial console device file
		tty0 c 4 0 	# Serial terminal device file
		tty1 c 4 1 	#
		tty2 c 4 2 	#
		tty3 c 4 3 	#
		tty4 c 4 4 	#
		tty5 c 4 5 	#
	/etc			# Repository for config files
		inittab		# The inittab
		/init.d		# Repository for init config files
			rcS	# The script run at sysinit
	/proc			# The /proc file system
	/sbin			# Repository for accessory binary files
	/tmp			# Repository for temporary files
	/var			# Repository for optional config files
	/usr			# Repository for user files
	/sys			# Repository for system service files
	/media			# Mount point for removable storage

------------------------Lecture 3 : Anatomy Of Linux Based Embedded System-------------------------

Linux kernel is Monolithic Kernel separated into User and Kernel Space. User and Kernel Space communicate through system calls.

The Kernel can be divided in five subsystems:
Process scheduler
Memory manager
Virtual file system
Inter-process communication
Network
Most of them are composed of:
Hardware-independent code
Hardware-dependent code

The MMU (Memory Management Unit Part Of Linux Kernel) detects when a user process accesses a memory address that is not currently mapped to a physical memory location. The MMU notifies the Linux Kernel the event known as page fault

-----Memory Manager External Interfaces------

System call interface:
malloc()/free(): allocate or free a region of memory for the process's use
mmap()/munmap()/msync()/mremap(): map files into virtual memory regions
mprotect(): change the protection on a region of virtual memory
mlock()/mlockall()/munlock()/munlockall(): super-user routines to prevent memory being swapped
swapon()/swapoff(): super-user routines to add and remove swap files for the system


Intra-Kernel interface:
kmalloc()/kfree(): allocate and free memory for use by the kernel’s data structures
verify_area(): verify that a region of user memory is mapped with required permissions
get_free_page()/free_page(): allocate and free physical memory pages.


---------Virtugal File System (VFS)--------------

VFS is responsible for providing : 
   High Speed access to files
   Enforces policies not to loose or corrupt data.
   enforces policies to grant access to files only to allowed users, and it restricts user total file size with quotas.
External interface:
System-call interface based on normal operations on file from the POSIX standard (e.g. open/close/read/write)
Intra-kernel interface based on i-node interface and file interface. 
The i-node stores all information about a file except it´s data and name, Whenever a file is created it is assigned a name
and a unique i-node number.

VFS I- Node Interface Provided Functions/API´s : 

create(): creates a file in a directory
lookup(): finds a file by name within a directory
link()/symlink()/unlink()/readlink()/follow_link(): manages file system links
mkdir()/rmdir(): creates or removes sub-directories
mknod(): creates a directory, special file, or regular file

readpage()/writepage(): reads or writes a page of physical memory
truncate(): sets the length of a file to zero
permission(): checks to see if a user process has permission to execute an operation
smap(): maps a logical file block to a physical device sector
bmap(): maps a logical file block to a physical device block
rename(): renames a file or directory


VFS File Interface Functions/API´s : 

open()/release(): opens or closes the file
read()/write(): reads or writes the file
select(): waits until the file is in a particular state (readable or writeable)
lseek(): moves to a particular offset in the file
mmap(): maps a region of the file onto the virtual memory of a user process.

fsync()/fasync(): synchronizes any memory buffers with the physical device
readdir(): reads the files that are pointed to by a directory file
ioctl(): sets file attributes
check_media_change(): checks to see if a removable media has been removed
revalidate(): verifies that all cached information is valid


---Device Drivers----
Device drivers provide a uniform interface to access hardware devices:

Character-based devices are hardware devices accessed sequentially (e.g. serial port).
Block-based devices are devices that are accessed randomly and whose data is read/written in blocks (e.g. hard disk unit).

Device drivers use the file interface abstraction of VFS for accessing deice drivers in user space :
Each device can be accessed as a file in the file system through a special file, the device file, associated with it. 
A new device driver is a new implementing of the hardware-specific code to customize the file interface abstraction 


-----Device Trees--------

In Arm architecture, all device tree source files are now located in either arch/arm/boot/dts or arch/arm64/boot/dts.
.dts files for board-level definitions
.dtsi files for included files

A tool, the device tree compiler, compiles the source into a binary form: the device tree blob (DTB).
The DTB is loaded by the bootloader and parsed by the kernel at boot time.
Device tree files are not monolithic.  They can be split in several files, including each other.



------------------------Lec 4 : Configuration and Build Process--------------


Building an embedded Linux system is a complex operation.

Multiple sources shall be configured and compiled.
Root file system shall be updated at each build through a non-trivial task.
In cases of multiple hw and multiple hw configurations, manual iteration is needed.

Tools, known as build systems, are available to automate such operations.

Build systems takes care of:

Building the cross compiler for the selected embedded system CPU
Managing bootloader/kernel/system programs configuration
Managing bootloader/kernel/system program build
Preparation of the root file system and boot device image preparation


----------------Yocto---------------------

Yocto has following features : 
Provides core recipes and use layers to get support for more packages and more machines.
In Yocto Custom modifications should stay in a separate layer.
Versatile build system: tries to be as flexible as possible and to handle most use cases.
Open community but governed by the Yocto Project Advisory Board.


In Yocto the configuration is separated in multiple parts:

.Distribution configuration (general configuration, toolchain selection, etc.)

.Machine configuration (defines the hw architecture, hw features, BSP)

.Image recipe (what system programs should be installed on the target)

.Local configuration (e.g., how many threads to use when compiling, whether to remove build artifacts, etc.)

.Allows to build the same image for different machines or using different distributions or different images for one machine


Yocto is Collaboration of multiple projects that make up the “Yocto Project”

Bitbake: build tool.

OpenEmbedded core: software framework used for creating Linux distributions. 

Poky: a reference distribution of the Yocto Project, containing the OpenEmbedded Build System (BitBake and OpenEmbedded Core) and a set of metadata to start building custom embedded Linux systems .

Application Development Toolkit: provides application developer a way to write sw running on the custom-built embedded Linux system without the need for knowing build systems.

---------Yocto Build System------------------

Yocto is composed of several layers : Developer Specific Layer. 
                                      Commercial Layer from operating system vendor.
                                      User interface-specific layer.
                                      Board Support Package layer.
                                      Yocto-specific layer metadata (meta-yocto).
                                      OpenEmbedded core metadata (oe-core)

These layers are containers for building blocks of the system.
These yocto layers do not contain components source code but only meta data i.e. recipes which define how to build outputs
called packages.
 
------------Yocto Build System Configuration Files-------------

meta/conf/bitbake.conf – default configuration.

build/conf/bblayers.conf – layers to be used during build process.

*/conf/layers.conf – layer configuration. 


-----build/conf/local.confl file-----------

used to override the default configuration and define what to build.
BB_NUMBER_THREADS and PARALLEL_MAKE
MACHINE settings
DISTRO settings
INCOMPATIBLE_LICENSE = “GPLv3”
EXTRA_IMAGE_FEATURES

Example :   MACHINE ?= "raspberrypi3"
            PREFERRED_VERSION_linux-raspberrypi = "4.%"
            DISTRO_FEATURES:remove = "x11 wayland"
            DISTRO_FEATURES:append = " systemd"
            VIRTUAL-RUNTIME_init_manager = "systemd"
            ENABLE_UART = "1

--------build/conf/bblayers.conf file---------

Used to configure which layers to use.
Add Yocto Project Compatible layers to the BBLAYERS
Default: meta (oe-core), meta-yocto, and meta-yocto-bsp

Example : 

bblayer.conf (fragment)

BBLAYERS = " \
  ${BSPDIR}/sources/poky/meta \
  ${BSPDIR}/sources/poky/meta-yocto \
  ${BSPDIR}/sources/poky/meta-yocto-bsp \
  \
  ${BSPDIR}/sources/meta-openembedded/meta-oe \
  ${BSPDIR}/sources/meta-openembedded/meta-multimedia \
  ${BSPDIR}/sources/meta-openembedded/meta-networking \
  ${BSPDIR}/sources/meta-openembedded/meta-python \
  \
  ${BSPDIR}/sources/meta-fsl-arm \
  ${BSPDIR}/sources/meta-fsl-arm-extra \
  ${BSPDIR}/sources/meta-fsl-demos \
  ${BSPDIR}/sources/meta-raspberrypi \

		
The above Recipes inherit the system configuration and adjust it to describe how to build and package the software.
Can be extended and enhanced via layers
Compatible with OpenEmbedded

Example : 

rpi-basic-image.bb (fragment)

# Base this image on rpi-hwup-image
include rpi-hwup-image.bb

SPLASH = "psplash-raspberrypi"

IMAGE_FEATURES += "ssh-server-dropbear splash"

---------------meta-yocto/conf/distro/poky.conf – distribution policy-----------

----------------meta-yocto-bsp/conf/machine/board-name.conf -----------
Defines configuration of the board support pacakge. ( Here we add our developed kernel Module)
Define board specific kernel configuration 
Processor/SOC Tuning files. 
Machine configuration refers to kernel sources.
Compatible with OpenEmbedded.

Example : 
raspberrypi3.conf (fragment)

#@TYPE: Machine
#@NAME: RaspberryPi 3 Development Board
#@DESCRIPTION: Machine configuration for the RaspberryPi 3

MACHINEOVERRIDES = "raspberrypi2:${MACHINE}"

MACHINE_EXTRA_RRECOMMENDS += " kernel-modules wl18xx-conf 
	uim-sysfs bt-firmware gator"

include conf/machine/raspberrypi2.conf

SERIAL_CONSOLE = "115200 ttyS0"

KERNEL_MODULE_AUTOLOAD += "g_serial hello"

MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS += "kernel-module-gator"


----------meta/conf/machine/include/tune-CPU-name.inc – CPU-specific configuration-----------



------------Build System Workflow Distribution Policy-------------------

Defines distribution policies that affect the way individual recipes are built
May set alternative preferred versions of recipes
May enable/disable features
May configure specific package rules
May adjust image deployment settings
Enabled via the DISTRO setting

Four predefined settings:
poky-bleeding: enables bleeding edge packages
poky: core distribution definition, defines the base
poky-lsb: enable items required for LSB support
poky-tiny: construct a smaller than normal system


----------Build System Workflow : Source Fetching--------------

Recipes tell the location of all sources, patches, and files.
These may exist on the internet or be local (See SRC_URI in the *.bb files).
Bitbake can get the sources from git, svn, bzr, or tarballs.
Versions of packages can be fixed or updated automatically (Add SRCREV_pn-PN = “${AUTOREV}” to local.conf).

----------Build System Workflow : Patching--------------

Once sources are obtained, they are extracted.
Patches are applied in the order they appear in SRC_URI.
In this stage, application-specific patches are applied.
Custom modifications to the open-source code that are mandated by the specific application for which the embedded system is intended for.

--------Build System Workflow : Output Analysis------------
Support the popular formats: RPM, Debian, and ipk.
Set preferred format using PACKAGE_CLASSES in local.conf 
Package files can be manually defined to override automatic settings


**********Setting Up Yocto In Development PC For Raspberry Pi3*************

We will need to follow same steps if we had other board or any other SoC processor, Following commands download the packages,software,utilties required by Yocto. In the end we clone
the Yocto poky repository git://git.yoctoproject.org/poky,  open-embedded layer repo git://git.openembedded.org/meta-openembedded ,  meta-raspberrypi layer from git://git.yoctoproject.org/meta-raspberrypi , for other board we will clone other relevant repo. 


sudo apt-get install gawk wget git diffstat unzip texinfo gcc-multilib build-essential 

Where   "gawk"            is a programming language to manipulate or extract data, generate reports, match patterns, perform 
                          calculations, and more, with great flexibility.  https://www.redhat.com/sysadmin/beginners-guide-gawk 
                    
       "wget"             is a program for retrieves content from web servers.
       "diffstat"         is a program that is useful for reviewing large, complex patch files.
       "texinfo"          generating documentation in both on-line and printed form with a single source file.
       "gcc-multilib"     useful for cross-compiling a program to run on a different processor architecture.
       "build-essential"  form of meta-packages that are essential to compile software. They contain the GNU/g++ compiler 
                          collection, GNU debugger, and a few more libraries and tools that are needed for compiling a program.
                          https://packages.ubuntu.com/focal/build-essential 

sudo apt-get install chrpath socat libsdl1.2-dev xterm ncurses-dev lzop

Where  "chrpath"         Allows you to modify the dynamic library load path (rpath and runpath) of compiled programs and libraries.
        "socat"          Allows for bidirectional data transfers from one location to another. https://www.redhat.com/sysadmin/getting-started-socat
        "libsdl1.2"      A cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D.
                         https://github.com/libsdl-org/SDL

        "xterm"          Standard terminal emulator of the X Window System, providing a command-line interface within a window.
        "ncurses-dev"    A programming library providing an application programming interface (API) that allows the programmer to write text-based user interfaces (TUI) in a terminal-
                         independent manner.
        "lzop"           A file compressor which is very similar to gzip. https://www.lzop.org/

sudo apt-get install minicom u-boot-tools curl  

Where   "minicom"       A serial communication program that connects to devices through a GNU/Linux PC's serial ports. https://wiki.emacinc.com/wiki/Getting_Started_With_Minicom
        "u-boot-tools"  Includes programs for generating and listing U-Boot(Bootloader) images in various formats:  - mkimage    - dumpimage   - mksunxiboot    - mkenvimage
                        https://packages.debian.org/sid/u-boot-tools
        
         "curl"         Library and command-line tool for transferring data using various network protocols. https://curl.se/


mkdir ~/bin
Install the repo Utility  :  curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo

Where  "repo"           Utility is used To simplify fetching sources and setting up the Yocto build environment we have decided to use the Google repo 248 tool, which allows fetching  
                        sources from multiple location in a single command based on manifest files (xml).   https://hub.mender.io/t/google-repo/58
                        

 
***************Setting Up Yocto*************** 

The following steps information is also available here : https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html
https://docs.yoctoproject.org/brief-yoctoprojectqs/

i).  git clone git://git.yoctoproject.org/poky 

Where "poky" is a reference distribution provided by Yocto, it can be customized through recipes according to a certain application and target hardware.
 
ii). git clone git://git.openembedded.org/meta-openembedded

Where "OpenEmbedded" is a build framework of recipes and packages. OpenEmbedded supports many hardware architectures with cross-compilation infrastructure.

iii). git clone git://git.yoctoproject.org/meta-raspberrypi

Where meta-raspberrypi is a layer providing recipe for generating embedded linux targetting raspberry pi SoC and board.

*********To establish Ethernet Connection With Our Raspberry Pi Board ********

Edit the poky/meta/recipes-core/init-ifupdown/init-ifupdown-1.0/interfaces file and add following lines 

iface eth0 inet static
        address 192.168.1.2
        netmask 255.255.255.0
        gateway 192.168.1.1
        network 192.168.1.0
 

iv). source poky/oe-init-build-env rpi-build
     Configured the Yocto environment to build the poky (embedded linux ) source for Raspberry Pi3, Where we are already in Yocto directory containing all the layers.
                    
The mentioned poky source was cloned earlier from git clone git://git.yoctoproject.org/poky
The Yocto Project has extensive documentation about OE including a reference
manual which can be found at:
    https://docs.yoctoproject.org

For more information about OpenEmbedded see the website:
    https://www.openembedded.org/


### Shell environment set up for builds. ###

You can now run 'bitbake <target>'

Common targets are:
    core-image-minimal
    core-image-full-cmdline
    core-image-sato
    core-image-weston
    meta-toolchain
    meta-ide-support

You can also run generated qemu images with a command like 'runqemu qemux86-64'.

Other commonly useful commands are:
 - 'devtool' and 'recipetool' handle common recipe tasks
 - 'bitbake-layers' handles common layer tasks
 - 'oe-pkgdata-util' handles common target package tasks

v) . Edit the local.conf file accordingly 

Example :
MACHINE ?= "raspberrypi3"
PREFERRED_VERSION_linux-raspberrypi = "4.%"
DISTRO_FEATURES:append = " systemd x11 wayland"
VIRTUAL-RUNTIME_init_manager = "systemd"
ENABLE_UART = "1

vi). Add the relevant layers in bblayers.conf file 

Example : 
POKY_BBLAYERS_CONF_VERSION = "2"

BBPATH = "${TOPDIR}"
BBFILES ?= ""

BBLAYERS ?= " \
  /opt/Yocto/poky/meta \
  /opt/Yocto/poky/meta-poky \
  /opt/Yocto/poky/meta-yocto-bsp \
  /opt/Yocto/meta-openembedded/meta-oe \
  /opt/Yocto/meta-openembedded/meta-python \
  /opt/Yocto/meta-openembedded/meta-multimedia \
  /opt/Yocto/meta-raspberrypi \
:

 Where  meta-raspberrypi :  layer is used to build embedded linux image for raspberry pi board .     https://meta-raspberrypi.readthedocs.io/en/latest/readme.html
     
vii). Building the image for raspberry pi 3
bibake core-image-sato


Encountered Issues During Yocto Based Linux Image Build For Raspberry Pi3 : https://askubuntu.com/questions/162391/how-do-i-fix-my-locale-issue
                                                                            https://askubuntu.com/questions/599808/cannot-set-lc-ctype-to-default-locale-no-such-file-or-directory
                                                                            https://github.com/crops/poky-container/issues/67
                                                                            https://docs.yoctoproject.org/next/migration-guides/migration-3.4.html
                                                        Yocto is migrated : https://low-level.wiki/yocto/honister-upgrade.html
After stopping bitbake in the middle , it won´t work to resolve it do : rm bitbake.lock


---------------------------------Lecture 5 : Linux Kernel Modules-------------------------------------------

Linux provides an abstraction to make communication with I/O easy.
Software developer does not need to know every detail of the physical device.
Portability can be increased by using the same abstraction for different I/O devices.

Linux recognizes three classes of devices:

Character devices, which are devices that can be accessed as stream of words (e.g., 8-/16-/32-/… bits) as in a file; reading word n requires reading all the preceding words from 0 to n-1.

Block devices, which are devices that can be accessed only as multiples of one block, where a block is 512 bytes of data or more. Typically, block devices host file systems.

Network interfaces, which are in charge of sending and receiving data packets through the network subsystem of the kernel.

----------Virtual File System Abstraction---------------

Character/block devices are accessed as files stored in the file system, as each device is associated with a device file.
Typical usage:

Open the device file.
Read/Write data from/to device file.
Close the device file.
Linux forwards the open/read/write/close operations to the I/O device associated to the device file.
The operations for each I/O device are implemented by a custom piece of software in the Linux kernel: the device driver.

The VFS functions available to a user application are declared in the file fs.h include/linux/fs.h , In user level application we will need to include this file.


include/linux/fs.h : 

struct file_operations {
  struct module *owner;
  loff_t (*llseek) (struct file *, loff_t, int);
  ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
  ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
  ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
  ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
  int (*iterate) (struct file *, struct dir_context *);
  int (*iterate_shared) (struct file *, struct dir_context *);
  unsigned int (*poll) (struct file *, struct poll_table_struct *);
  long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
  long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
  int (*mmap) (struct file *, struct vm_area_struct *);
  int (*open) (struct inode *, struct file *);
  int (*flush) (struct file *, fl_owner_t id);
  int (*release) (struct inode *, struct file *);
  int (*fsync) (struct file *, loff_t, loff_t, int datasync);
  int (*aio_fsync) (struct kiocb *, int datasync);
  int (*fasync) (int, struct file *, int);
  int (*lock) (struct file *, int, struct file_lock *);
  ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
  unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
  int (*check_flags)(int);
  int (*flock) (struct file *, int, struct file_lock *);
  ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
  ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
  int (*setlease)(struct file *, long, struct file_lock **, void **);
  long (*fallocate)(struct file *file, int mode, loff_t offset,
  loff_t len);
  void (*show_fdinfo)(struct seq_file *m, struct file *f);
  #ifndef CONFIG_MMU
    unsigned (*mmap_capabilities)(struct file *);
  #endif
  ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
  loff_t, size_t, unsigned int);
  int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t,
  u64);
  ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *,
  u64);
 };



For character devices the most commonly used VFS functions are the following:

ssize_t (*read) (struct file *, char *__user, size_t, loff_t *): it reads data from a file.

ssize_t (*write) (struct file *,  const char *__user, size_t, loff_t *):  it writes data to a file.

int (*ioctl) (struct *inode, struct file *,  unsigned int, unsigned long): it performs custom operations to the file.

int (*open) ( struct *inode, struct file * ): it prepares a file for use.

int (*release) ( struct inode *, struct file * ): it indicates the file is no longer in use.



---------------The Device File Concept--------------

The device file is the intermediator through which a user application can exchange data with a device driver.

The device file does not contain any data, while its descriptor contains the relevant information to identify the corresponding driver:

The device file type, which could be either c = character device, b = block device, or p = named pipe (inter-process communication mechanism)

The major number, which is an integer number that identifies univocally a device driver in the Linux kernel

The minor number, which is used to discriminate among multiple instances of I/O devices handled by the same device driver

--------------The Linux Kernel Modules---------------

A device driver provides an I/O-device specific implementation of the Virtual File System abstraction, and it is located in the kernel space.

A device driver can be: Linked with the Linux Kernel and executed at system bootstrap.

                        Kernel module, which is loaded at runtime through suitable system programs, after the Linux Kernel is booted.


We use the following system programs for performing certian operations of : 
                      mknod  for Creating a Device File. 
                      insmod for Adding Kernel Module In Linux Kernel.
                      rmmod  for Removing Kernel Module From Linux Kernel. 
                      lsmod  for Listing Kernel Modules.

Functions provided by a kernel module:

Initialization function, called upon the execution of the insmod system program, takes care of making Linux aware that a new device driver is available.

Clean-up function, called upon the execution of rmmod, to remove the device driver from the Linux Kernel.

Custom-specific implementations of the VFS abstraction


----Linux Kernel Module Initialization Function--------


static dev_t dummy_dev;   					// Data structure containing the major number and the first minor number for the module. It identifies
                          					// univocally the module in the kernel. It shall be used when creating the device file associated with
                          					// the module.


struct cdev dummy_cdev;   					// Data structure used to describe the properties of a character device 

static char buffer[64];               				// Buffer used for displaying output messages on the Linux console


struct file_operations dummy_fops = {                   	// Data structure used to associate the VFS functions to their module-specific implementations.
								// In this example, the read() VFS function is implemented by the dummy_read() function.

    .owner = THIS_MODULE,
    .read = dummy_read,                                 	// read() VFS function is implemented by dummy_read() function.
};                                                              // read() VFS function is used at User level application.

static int __init dummy_module_init(void)
{
    printk(KERN_INFO "Loading dummy_module\n");                 // Kernel equivalent of the printf().

    alloc_chrdev_region(&dummy_dev, 0, 1, "dummy_dev");         // The module initialization function. It is executed as soon as the module enters the Linux kernel and   								                // takes care of making the Kernel aware that the new module is available.
                                                                // Where : 	dev is the dynamically-selected major number of the module;
                                                                //         	0   here is first minor number for the module;
                                                                //         	1   here is count, informing kernel to reserve above minor number for only this module.
                                                                // 	dummy_dev   is the name of kernel module.  
   
    printk(KERN_INFO "%s\n", format_dev_t(buffer, dummy_dev));  // prints on the Linux console the major number and the minor number associated with the just-registered character device.
    
    cdev_init(&dummy_cdev, &dummy_fops);                        // Initializing the character device data structure
                                                                // where:   cdev   is the structure to initialize 
                                                                     dummy_fops    is the file_operations for the device.   

    dummy_cdev.owner = THIS_MODULE;                             // Setting the owner of the module using the THIS_MODULE macro.

    cdev_add(&dummy_cdev, dummy_dev, 1);                        // Adding the character device to the Linux Kernel.
                                                                // Where  dummy_cdev   is a pointer to character device structure which is already initialized
                                                                //        dummy_dev    is major number of the device.   
                                                                //            1      is showing that only one i.e. this module is assocaited with this minor number. 

    return 0;                                                   // Indicating the function terminated correctly.  A non zero value indicates an error occurred.
                           

}



--------Linux Kernel Module : The Clean Up Function------------

static void __exit dummy_module_cleanup(void)                    
{
    printk(KERN_INFO "Cleaning-up dummy_dev.\n");              

    cdev_del(&dummy_cdev);                                       // Removing the character device from the Linux kernel.           
    unregister_chrdev_region(dummy_dev, 1);                      // Freeing the range of major/minor numbers previously registered.
}



-------Linux Kernel Module : Implementation of Read VFS Function In Kernel Module---------

ssize_t dummy_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)      // Where filp is the pointer to the data structure describing the opened file;
                                                                                          //        buf is the bufer to fill with the data read from the file;
               									          //        count is the size of the buffer		                                                                                      										          //        f_pos is the current reading position in the file.                                       

{
    printk(KERN_INFO "Dummy read (count=%d, offser=%d)\n", (int)count, (int)*f_pos );     // printing a message to show that the read functions has been executed.

    return 1;                                                                             // Returning the number of byte read from the file. 
											  // Returning 0 will block the caller application, which will wait until at least 
                                                                                          // one byte is returned.
 
}


-----------------------------------------------Lecture 6 : Communication Between Kernel and User Space--------------------------------------------------

When designing an application that communicates with custom hardware, two levels shall be considered:

User level, where the behavior of the application is defined using virtual file system (VFS) calls to communicate with the hardware.
Module level, where the behavior of each VFS function is implemented based upon the functionalities the hardware implements.

Different hardware may require different implementations of the same VFS function.
At the user-level, the programmer shall be aware of the functionalities the hardware provides, and shall use the VFS calls accordingly.

-------------The CPU/Device Interface-----------

Memory mapped: each register is associated to an address.
Through GPIO, where each register is associated to a set of GPIOs.

The module-level implementation will be affected by the adopted CPU/Device Interface.
The user-level implementation will abstract these details

------------The Module Level----------------

At this level, the different functionalities of the device shall be enumerated, and an association shall be established with the VFS functionalities.
In our example, the device L supports the following functionalities:

Reset: L is disabled, and the blink rate register is set to zero.  
                       Here Both the blink rate and enable registers are set to zero. This operation is done once, when starting using the device.

Program: The blink rate register is set to a user-defined value.
                      The blink rate register is set to a user defined value. This operation can be done multiple times, during the device usage

Enable: L is enabled.
                     The enable register is set to one. This operation can be done multiple times, during the device usage

Disable: L is disabled.
                    The enable register is set to zero. This operation can be done multiple times, during the device usage

Poll rate: L returns the content of the blink rate register.
                    The blink rate register content is provided to the user level. This operation can be done multiple times, during the device usage.


Poll state: L returns the content of the enable register.
                    The enable register content is provided to the user level. This operation can be done multiple times, during the device usage

Power-off: L terminates its operation and starts waiting for the next reset.
                    The enable register content is set to zero. This operation is done once, after the last usage of the device.


The virtual file system functions that are typically used are:

open, which initiates the operations with the device

release, which terminates the operation with the device

write, which sends data coming from the user space to the device

read, which reads from the device and send them to the user space

ioctl, which performs custom operations


Relationship Between VFS Functions and Module Level Functions is : 

Device Function             VFS Function

Reset        <---------->    Open           Used for establishing connection with the device.

Power-off    <---------->    release        for terminating the connection with device.

Poll state   <---------->    read           Used to send data from device to application, Enable register is selected as target for read operation using ioctl() function.

Poll rate    <---------->    read           Used to send data from device to application, Blink rate register is selected as target for read operation using ioctl() function.

Disable      <---------->    write          Used to send data to the device and Enable register is selected as target for read operation using ioctl() function.

Enable       <---------->    write          Used to send data to the device and Enable register is selected as target for write operation using ioctl() function.

Program      <---------->    write          Used to send data to the device and Blink Rate register is selected as target for write operation using ioctl() function.
       

----------Structure for definining File Operations In Kernel Module-----------

static dev_t L_dev;

struct cdev L_cdev;

struct file_operations L_fops = {

    .owner 	= THIS_MODULE,
    .open 	= L_open_close,
    .release 	= L_open_close,
    .write 	= L_write,
    .read 	= L_read,
    .ioctl 	= L_ioctl,

};


-------The Module Level: ioctl() Implementation-----------

static ssize_t L_ioctl(struct inode *inode, struct file *filep, unsigned int cmd, unsigned long arg)
{ 
  switch( cmd )
  {
    case BLINK_RATE:				// global symbol previously defined
      selected_register = BLINK_RATE;		// global variable previously defined
      break;
    case ENABLE:					// global symbol previously defined
      selected_register = ENABLE;
      break;
  }	

  return 0;
} 
----------------The Module Level: open()/release() Implementation----------

It disables the device and sets the blink rate to zero. The same operations are valid for open() and release() functions.

static int L_open_close(struct inode *inode, struct file *file)
{ 
  selected_register = ENABLE;			// it selects the target for read/write operation.
  WRITE_DATA_TO_THE_HW( 0 );			// it sends 0 to the enable register.
						// it abstracts the low-level CPU/device L interface.

  selected_register = BLINK_RATE;			// it selects the target for read/write operation.
  WRITE_DATA_TO_THE_HW( 0 );			// it sends 0 to the blink register.
	
  return 0;
} 
----------------------The Module Level: read() Implementation--------------------

It reads from the ioctl() selected register and pass the data to the user.

static ssize_t L_read(struct file *filp, char *buffer, size_t length, loff_t * offset) 
{ 
  int data;

  READ_DATA_FROM_THE_HW( &data );			// it abstracts the low-level CPU/device L interface.
  copy_to_user(buffer, &data, 4 );			// see next slide

  return 4; 					// it returns the number of bytes read.
}


------------------Passing Data to/from the Kernel----------------

Kernel and application are running in two different memory spaces.
Specific functions are needed to move data between them.

    copy_to_user(void __user *to, const void *from, unsigned long n);    //Move data from kernel space to user space.


--------------The Module Level: write() Implementation---------------

static ssize_t L_write(struct file *filp, char *buffer, size_t length, loff_t * offset)  // writes to ioctl() selected register
{ 
  WRITE_DATA_TO_THE_HW( buffer );		
	
  return 1; 
}


-----------------The Module Level: Communication with the Device--------------------

Hidden in implementation of functions : READ_DATA_FROM_THE_HW() , WRITE_DATA_TO_HW()

Implementation depends on the CPU/Device L connection

Memory mapped example:
Blink rate register: 0xf0080000
Enable register:     0xf0080004

GPIO example:
Blink rate register: GPIO(0-31) (MSB first)
Enable register: GPIO(32)


----------------------Memory Mapped I/0 Implementation Of Kernel Module Device Read, Write Funtions---------------------------


Memory areas can be used if:
Available
Reserved

Following Functions required for Memory Mapped I/O based Implementation of read and write data to/from  device at kernel Module level

int check_region( unsigned long first, unsigned long n)                      //It checks whether the desired addresses are available
int request_region( unsigned long first, unsigned long n, const char *name)  // It reserves the desired addresses
int release_region( unsigned long first, unsigned long n)                    // It sets the desired addresses free


----------Memory Mapped I/O Module Initialization Function------------

static int __init L_module_init(void)
{
  int res;
  alloc_chrdev_region(&L_dev, 0, 1, ”L_dev");
  printk(KERN_INFO "%s\n", format_dev_t(buffer, L_dev));
  cdev_init(&L_cdev, &L_fops);
  L_cdev.owner = THIS_MODULE;
  cdev_add(&L_cdev, L_dev, 1);

  r = check_region( ioremap(0xf0080000, 4 ), 8 );      // ioremap() Translates the physical address of the device (as defined by the memory map) into the corresponding virtual address.
  if(r) {
   printk( KERN_ALERT ”Unable to reserve I/O memory\n");
   return –EINVAL;
  }
  request_region(ioremap(0xf0080000, 4), 8, ”DevL");
  return 0;
}


---------Mmeory Mapped I/O Clean Up Function-------------

static void __exit L_module_cleanup(void)
{
  cdev_del(&L_cdev);
  unregister_chrdev_region(L_dev, 1);

  release_region(ioremap(0xf0080000, 4 ), 8);
}

---------Mmeory Mapped I/O Read Function-------------

int	READ_DATA_FROM_THE_HW( int *data )
{
  int	tmp;

  switch( selected_register )
  {
    case BLINK_RATE:
      tmp = inl( ioremap(0xf0080000, 4) );	        // inl(): it reads 32-bit words, 
                                                        // inw(): it reads 16-bit words. 
                                                        // inb(): it reads 8-bit words.
      break;
    case ENABLE:
      tmp = inl( ioremap(0xf0080000, 4)+4 );
      break;
    }
    *data = tmp;

    return 4;
}


---------Mmeory Mapped I/O Write Function-------------

int	WRITE_DATA_TO_THE_HW( char *data )
{
  switch( selected_register )
  {
    case BLINK_RATE:
      outl( (int)*data, ioremap(0xf0080000, 4) );	// outl(): it write 32-bit words, 
                                                        // outw(): it write 16-bit words. 
                                                        // outb(): it writes 8-bit words.
      break;
    case ENABLE:
      outl( (int)*data, ioremap(0xf0080000, 4)+4 );
      break;
    }
    
    return 4;
}


----------------------GPIO I/0 Implementation Of Kernel Module Device Read, Write Funtions---------------------------

Prior to GPIO use, it shall be reserved for the module.

int gpio_request(unsigned gpio, const char *label)       //It checks whether the desired GPIO is available, and if yes, reserves it.
void gpio_free(unsigned gpio)                            // It sets the desired GPIO free.

----------GPIO I/O Module Initialization Function------------

static int __init L_module_init(void)
{
  int i, r;
  alloc_chrdev_region(&L_dev, 0, 1, ”L_dev");
  printk(KERN_INFO "%s\n", format_dev_t(buffer, L_dev));
  cdev_init(&L_cdev, &L_fops);
  L_cdev.owner = THIS_MODULE;
  cdev_add(&L_cdev, L_dev, 1);

  for( i = 0; i < 32; i++ ) {                           
  
    r = gpio_request( i );                                // GPIO shall be checked and reserved one by one.
    if (r) { 
      printk( KERN_ALERT ”Unable to reserve GPIO\n");
      return –EINVAL;
    }
  }
  return 0;
}


----------GPIO I/O Module  Clean Up Function------------

static void __exit L_module_cleanup(void)
{
  int i;
  
  cdev_del(&L_cdev);
  unregister_chrdev_region(L_dev, 1);

  for( i = 0; i < 32; i++ )
    gpio_free( i );                                      // GPIO shall be freed one by one.

}

----------GPIO I/O Module Read() Function------------



int	READ_DATA_FROM_THE_HW( int *data )
{
  int	tmp = 0, i;

  switch( selected_register )
  {
    case BLINK_RATE:
      for( i = 0; i < 31; i++ ) {
        gpio_direction_input( i );                     // GPIO direction shall be set to input.
      
        tmp = (tmp << 1) | gpio_get_value( i );        // GPIO value shall be read one by one. The resulting word is built MSB first.

      }
      break;
    case ENABLE:
      gpio_direction_input( 32 );
      tmp |= gpio_get_value( 32 )
      break;
    }
    *data = tmp;

    return 4;
}

----------GPIO I/O Module Write() Function------------

int	WRITE_DATA_TO_THE_HW( int data )
{
  int	i;
  switch( selected_register ) {
    case BLINK_RATE:
      for( i = 0; i < 31; i++ ) {
        gpio_direction_output( i, 0 );                // GPIO direction shall be set to output, with default value on the GPIO set to 0.

        gpio_set_value( i, (data & (1 << i)) );       // GPIO value shall be written one by one.

      }
      break;
    case ENABLE:
      gpio_direction_output( 32, 0 );
      gpio_set_value( 32, data & 0x00000001 );
      break;
  }

  return 4;
}



















